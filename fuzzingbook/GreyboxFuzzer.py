#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# This material is part of "The Fuzzing Book".
# Web site: https://www.fuzzingbook.org/html/GreyboxFuzzer.html
# Last change: 2019-05-19 14:42:27+02:00
#
#!/
# Copyright (c) 2018-2019 Saarland University, CISPA, authors, and contributors
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
# OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import random

class Mutator(object):
    def __init__(self):
        self.mutators = [
            self.delete_random_character,
            self.insert_random_character,
            self.flip_random_character
        ]

    def insert_random_character(self,s):
        """Returns s with a random character inserted"""
        pos = random.randint(0, len(s))
        random_character = chr(random.randrange(32, 127))
        return s[:pos] + random_character + s[pos:]

    def delete_random_character(self,s):
        """Returns s with a random character deleted"""
        if s == "":
            return self.insert_random_character(s)

        pos = random.randint(0, len(s) - 1)
        return s[:pos] + s[pos + 1:]

    def flip_random_character(self,s):
        """Returns s with a random bit flipped in a random position"""
        if s == "":
            return self.insert_random_character(s)

        pos = random.randint(0, len(s) - 1)
        c = s[pos]
        bit = 1 << random.randint(0, 6)
        new_c = chr(ord(c) ^ bit)
        return s[:pos] + new_c + s[pos + 1:]

    def mutate(self, inp):
        """Return s with a random mutation applied"""
        mutator = random.choice(self.mutators)
        return mutator(inp)

# ### Power Schedules
class Seed(object):    
    def __init__(self, data):
        """Set seed data"""
        self.data = data
        
    def __str__(self):
        """Returns data as string representation of the seed"""
        return self.data
    __repr__ = __str__

class PowerSchedule(object):    
    def assignEnergy(self, population):
        """Assigns each seed the same energy"""
        for seed in population:
            seed.energy = 1

    def normalizedEnergy(self, population):
        """Normalize energy"""
        energy = list(map(lambda seed: seed.energy, population))
        sum_energy = sum(energy)  # Add up all values in energy
        norm_energy = list(map(lambda nrg: nrg/sum_energy, energy))
        return norm_energy
    
    def choose(self, population):
        """Choose weighted by normalized energy."""
        import numpy as np

        self.assignEnergy(population)
        norm_energy = self.normalizedEnergy(population)
        seed = np.random.choice(population, p=norm_energy)
        return seed

# ### Runner and Sample Program

if __package__ is None or __package__ == "":
    from MutationFuzzer import FunctionCoverageRunner
else:
    from .MutationFuzzer import FunctionCoverageRunner

if __package__ is None or __package__ == "":
    from Fuzzer import Fuzzer
else:
    from .Fuzzer import Fuzzer


class MutationFuzzer(Fuzzer):
    def __init__(self, seeds, mutator, schedule):
        self.seeds = seeds
        self.mutator = mutator
        self.schedule = schedule
        self.inputs = []
        self.reset()

    def reset(self):
        """Reset the initial population and seed index"""
        self.population = list(map(lambda x: Seed(x), self.seeds))
        self.seed_index = 0

    def create_candidate(self):
        """Returns an input generated by fuzzing a seed in the population"""
        seed = self.schedule.choose(self.population)

        # Stacking: Apply multiple mutations to generate the candidate
        candidate = seed.data
        trials = min(len(candidate), 1 << random.randint(1,5))
        for i in range(trials):
            candidate = self.mutator.mutate(candidate)
        return candidate

    def fuzz(self):
        """Returns first each seed once and then generates new inputs"""
        if self.seed_index < len(self.seeds):
            # Still seeding
            self.inp = self.seeds[self.seed_index]
            self.seed_index += 1
        else:
            # Mutating
            self.inp = self.create_candidate()
            
        self.inputs.append(self.inp)
        return self.inp

class GreyboxFuzzer(MutationFuzzer):    
    def reset(self):
        """Reset the initial population, seed index, coverage information"""
        super().reset()
        self.coverages_seen = set()
        self.population = [] # population is filled during greybox fuzzing
           
    def run(self, runner):
        """Run function(inp) while tracking coverage.
           If we reach new coverage,
           add inp to population and its coverage to population_coverage
        """
        result, outcome = super().run(runner)
        new_coverage = frozenset(runner.coverage())
        # print("new_coverage")
        # print(new_coverage)
        # print("self.coverages_seen")
        # print(self.coverages_seen)
        # print(new_coverage in self.coverages_seen)
        if new_coverage not in self.coverages_seen:
            # We have new coverage
            seed = Seed(self.inp)
            seed.coverage = runner.coverage()
            self.coverages_seen.add(new_coverage)
            self.population.append(seed)

        return (result, outcome)


import pickle  # serializes an object by producing a byte array from all the information in the object
import hashlib # produces a 128-bit hash value from a byte array

def getPathID(coverage):
    """Returns a unique hash for the covered statements"""
    pickled = pickle.dumps(coverage)
    return hashlib.md5(pickled).hexdigest()

class AFLFastSchedule(PowerSchedule): 
    def __init__(self, exponent):
        self.exponent = exponent
            
    def assignEnergy(self, population):
        """Assign exponential energy inversely proportional to path frequency"""
        for seed in population:
            seed.energy = 1 / (self.path_frequency[getPathID(seed.coverage)] ** self.exponent)

class CountingGreyboxFuzzer(GreyboxFuzzer):
    def reset(self):
        """Reset path frequency"""
        super().reset()
        self.schedule.path_frequency = {}
    
    def run(self, runner):
        """Inform scheduler about path frequency"""
        result, outcome = super().run(runner)

        path_id = getPathID(runner.coverage())
        if not path_id in self.schedule.path_frequency:
            self.schedule.path_frequency[path_id] = 1
        else:
            self.schedule.path_frequency[path_id] += 1
            
        return(result, outcome)

class DictMutator(Mutator):
    def __init__(self, dictionary):
        super().__init__()
        self.dictionary = dictionary
        self.mutators.append(self.insert_from_dictionary)
        
    def insert_from_dictionary(self, s):
        """Returns s with a keyword from the dictionary inserted"""
        pos = random.randint(0, len(s))
        random_keyword = random.choice(self.dictionary)
        return s[:pos] + random_keyword + s[pos:]

class MazeMutator(DictMutator):
    def __init__(self, dictionary):
        super().__init__(dictionary)
        self.mutators.append(self.delete_last_character)
        self.mutators.append(self.append_from_dictionary)

    def append_from_dictionary(self,s):
        """Returns s with a keyword from the dictionary appended"""
        random_keyword = random.choice(self.dictionary)
        return s + random_keyword
    
    def delete_last_character(self,s):
        """Returns s without the last character"""
        if (len(s) > 0):
            return s[:-1]

if __name__ == "__main__":
    n = 10000
    seed_input = " " # empty seed

    maze_mutator = MazeMutator(["L","R","U","D"])
    maze_schedule = PowerSchedule()
    maze_fuzzer  = GreyboxFuzzer([seed_input], maze_mutator, maze_schedule)

    start = time.time()
    maze_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)
    end = time.time()

    "It took the fuzzer %0.2f seconds to generate and execute %d inputs." % (end - start, n)


def print_stats(fuzzer):
    total = len(fuzzer.population)
    solved = 0
    invalid = 0
    valid = 0
    for seed in fuzzer.population:
        s = maze(str(seed.data))
        if "INVALID" in s: invalid += 1
        elif "VALID" in s: valid += 1
        elif "SOLVED" in s: 
            solved += 1
            if solved == 1: 
                print("First solution: %s" % repr(seed))
        else: print("??")

    print("""Out of %d seeds, 
* %4d solved the maze, 
* %4d were valid but did not solve the maze, and 
* %4d were invalid""" % (total, solved, valid, invalid))   

if __name__ == "__main__":
    print_stats(maze_fuzzer)


# ### Computing Function-Level Distance

if __name__ == "__main__":
    print('\n### Computing Function-Level Distance')




if __name__ == "__main__":
    target = target_tile()
    target


import networkx as nx
if __package__ is None or __package__ == "":
    from ControlFlow import get_callgraph
else:
    from .ControlFlow import get_callgraph


if __name__ == "__main__":
    cg = get_callgraph(maze_code)
    for node in cg.nodes():
        if target in node:
            target_node = node
            break
    target_node


if __name__ == "__main__":
    distance = {}
    for node in cg.nodes():
        if "__" in node: 
            name = node.split("__")[-1]
        else: 
            name = node
        try:
            distance[name] = nx.shortest_path_length(cg, node, target_node)
        except:
            distance[name] = 0xFFFF


if __name__ == "__main__":
    {k: distance[k] for k in list(distance) if distance[k] < 0xFFFF}


# ### Directed Power Schedule

if __name__ == "__main__":
    print('\n### Directed Power Schedule')




class DirectedSchedule(PowerSchedule):
    def __init__(self, distance, exponent):
        self.distance = distance
        self.exponent = exponent

    def __getFunctions__(self, coverage):
        functions = set()
        for f, _ in set(coverage):
            functions.add(f)
        return functions
    
    def assignEnergy(self, population):
        """Assigns each seed energy inversely proportional
           to the average function-level distance to target."""
        for seed in population:
            if not hasattr(seed, 'distance'):
                num_dist = 0
                sum_dist = 0
                for f in self.__getFunctions__(seed.coverage):
                    if f in list(distance):
                        sum_dist += distance[f]
                        num_dist += 1
                seed.distance = sum_dist / num_dist
                seed.energy = (1 / seed.distance) ** self.exponent

if __name__ == "__main__":
    directed_schedule = DirectedSchedule(distance, 3)
    directed_fuzzer  = GreyboxFuzzer([seed_input], maze_mutator, directed_schedule)

    start = time.time()
    directed_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)
    end = time.time()

    "It took the fuzzer %0.2f seconds to generate and execute %d inputs." % (end - start, n)


if __name__ == "__main__":
    print_stats(directed_fuzzer)


if __name__ == "__main__":
    y = [seed.distance for seed in directed_fuzzer.population]
    x = range(len(y))
    plt.scatter(x, y)
    plt.ylim(0,max(y))
    plt.xlabel("Seed ID")
    plt.ylabel("Distance");


class AFLGoSchedule(DirectedSchedule):
    def assignEnergy(self, population):
        """Assigns each seed energy inversely proportional
           to the average function-level distance to target."""
        min_dist = 0xFFFF
        max_dist = 0
        for seed in population:
            if not hasattr(seed, 'distance'):
                num_dist = 0
                sum_dist = 0
                for f in self.__getFunctions__(seed.coverage):
                    if f in list(distance):
                        sum_dist += distance[f]
                        num_dist += 1
                seed.distance = sum_dist / num_dist
            if seed.distance < min_dist: min_dist = seed.distance
            if seed.distance > max_dist: max_dist = seed.distance

        for seed in population:
            if (seed.distance == min_dist):
                if min_dist == max_dist:
                    seed.energy = 1
                else: 
                    seed.energy = max_dist - min_dist
            else:
                seed.energy = ((max_dist - min_dist) / (seed.distance - min_dist)) 

if __name__ == "__main__":
    aflgo_schedule = AFLGoSchedule(distance, 3)
    aflgo_fuzzer  = GreyboxFuzzer([seed_input], maze_mutator, aflgo_schedule)

    start = time.time()
    aflgo_fuzzer.runs(FunctionCoverageRunner(maze), trials=n)
    end = time.time()

    "It took the fuzzer %0.2f seconds to generate and execute %d inputs." % (end - start, n)


if __name__ == "__main__":
    print_stats(aflgo_fuzzer)


if __name__ == "__main__":
    for seed in aflgo_fuzzer.population:
        s = maze(str(seed.data))
        if "SOLVED" in s:
            filtered = "".join(list(filter(lambda c: c in "UDLR", seed.data)))
            print(filtered)
            break


# ## Lessons Learned

if __name__ == "__main__":
    print('\n## Lessons Learned')




# ## Next Steps

if __name__ == "__main__":
    print('\n## Next Steps')




import shutil
import os

if __name__ == "__main__":
    if os.path.exists('callgraph.dot'):
        os.remove('callgraph.dot')

    if os.path.exists('callgraph.py'):
        os.remove('callgraph.py')


# ## Background

if __name__ == "__main__":
    print('\n## Background')




# ## Exercises

if __name__ == "__main__":
    print('\n## Exercises')



